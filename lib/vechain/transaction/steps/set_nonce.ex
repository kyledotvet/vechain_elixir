defmodule VeChain.Transaction.Steps.SetNonce do
  @moduledoc """
  Pipeline step to set the nonce on a transaction.

  VeChain's nonce is **different from Ethereum** - it's not based on account
  state. Instead, it's a deterministic value generated from the transaction's
  signing hash and the current timestamp.

  This ensures uniqueness while allowing transactions to be sent without
  querying account state.

  If the transaction already has a nonce set, this step will not override it.

  ## Examples

      iex> tx = Transaction.new(chain_tag: 0x27)
      iex> |> Transaction.add_clause(Clause.transfer_vet("0x...", 1000))
      iex> tx = SetNonce.call(tx)
      iex> is_integer(tx.nonce)
      true
  """

  alias VeChain.{Transaction, Crypto.Blake2b}

  @doc """
  Sets the nonce if not already present.

  Generates a deterministic nonce from the transaction's signing hash
  and the current timestamp.

  ## Parameters

    * `tx` - Transaction struct
    * `opts` - Options:
      - `:nonce` - Override nonce value (optional)

  ## Returns

  Transaction with nonce set.
  """
  @spec call(Transaction.t(), keyword()) :: Transaction.t()
  def call(%Transaction{nonce: nonce} = tx, opts) when nonce != nil do
    # Nonce already set - don't override unless opts specify
    case Keyword.get(opts, :nonce) do
      nil -> tx
      override_nonce -> %{tx | nonce: override_nonce}
    end
  end

  def call(%Transaction{} = tx, opts) do
    # Generate nonce
    nonce =
      case Keyword.get(opts, :nonce) do
        nil -> generate_nonce(tx)
        override_nonce -> override_nonce
      end

    %{tx | nonce: nonce}
  end

  @doc """
  Generates a deterministic nonce for a transaction.

  The nonce is generated by:
  1. Getting the transaction's signing hash
  2. Combining with current timestamp
  3. Hashing with Blake2b
  4. Taking first 8 bytes as unsigned integer

  ## Parameters

    * `tx` - Transaction struct

  ## Returns

  Nonce as a non-negative integer.

  ## Examples

      iex> tx = Transaction.new(chain_tag: 0x27)
      iex> nonce = SetNonce.generate_nonce(tx)
      iex> is_integer(nonce)
      true
  """
  @spec generate_nonce(Transaction.t()) :: non_neg_integer()
  def generate_nonce(%Transaction{} = tx) do
    # Get signing hash (hash of unsigned transaction)
    signing_hash = Transaction.get_signing_hash(tx)

    # Get current timestamp in milliseconds
    timestamp = System.system_time(:millisecond)

    # Combine signing hash with timestamp
    nonce_input = signing_hash <> <<timestamp::64>>

    # Hash and take first 8 bytes as nonce
    nonce_hash = Blake2b.hash(nonce_input)
    <<nonce::unsigned-integer-size(64), _rest::binary>> = nonce_hash

    nonce
  end
end
